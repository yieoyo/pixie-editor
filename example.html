<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0 user-scalable=no"
    />
    <title>Pixie Example</title>
    <style>
      html,
      body,
      #editor-container {
        width: 100%;
        height: 100%;
        padding: 0;
        margin: 0;
        font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont,
          "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif,
          "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol",
          "Noto Color Emoji";
      }
      .canvas {
          position: absolute;
      }
      .canvas:hover {
          cursor: default;
      }
      .picture {
          position: absolute;
      }
      .button {
          padding: 4px;
          margin: 4px;
          border: 1px solid black;
          float: left;
      }
      .button:hover {
          background-color: blue;
          color: white;
          cursor: pointer;
      }
      #threshold {
          width: 95px;
          float: left;
      }
      .add-mode {
          cursor: copy !important;
      }
    </style>
  </head>

  <body>
    <div id="editor-container"></div>
    <!-- <nav class="z-navbar min-h-86 flex-shrink-0 px-16 relative overflow-hidden">
    </nav> -->

    <script src="dist/pixie.umd.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
    <script src="https://unpkg.com/magic-wand-tool@latest/dist/magic-wand.min.js"></script>
    <script>
      document.addEventListener("DOMContentLoaded", function () {
        let zNavbar = document.querySelector(".z-navbar");
        const magicBoxContainer = document.createElement("div");
        magicBoxContainer.innerHTML = `
        <div class="mt-2">(hold left mouse button and move to change the color threshold)</div>
        <div class="mt-2">(hold the CTRL key to add selection)</div>
        <div class="overflow-auto">
            <button class="bg-blue-500 text-white p-2 rounded-md cursor-pointer" onclick="trace()">Create polygons by current selection</button>
            <button class="bg-blue-500 text-white p-2 rounded-md cursor-pointer" onclick="paint('FF0000', 0.35)">Paint the selection</button>
        </div>
        <div class="overflow-auto">
            <div class="float-left mr-2">Blur radius: </div>
            <input id="blurRadius" type="text" onchange="onRadiusChange.apply(this, arguments)" class="float-left w-20 p-2 border border-gray-300 rounded-md mr-2"/>
            <div id="threshold" class="inline-block"></div>
        </div>

      `;
        zNavbar.parentNode.insertBefore(magicBoxContainer, zNavbar.nextSibling);
        // alert(document.getElementsByClassName("upper-canvas"));
        let upperCanvas = document.querySelector(".upper-canvas");

        if (upperCanvas) {
            upperCanvas.addEventListener("mouseup", onMouseUp);
            upperCanvas.addEventListener("mousedown", onMouseDown);
            upperCanvas.addEventListener("mousemove", onMouseMove);
            console.log("Element added");
        } else {
            console.error("Element not found");
        }
      });

      window.onload = function () {
        colorThreshold = 15;
        blurRadius = 5;
        simplifyTolerant = 0;
        simplifyCount = 30;
        hatchLength = 4;
        hatchOffset = 0;

        imageInfo = null;
        cacheInd = null;
        mask = null;
        oldMask = null;
        downPoint = null;
        allowDraw = false;
        addMode = false;
        currentThreshold = colorThreshold;

        document.onkeydown = onKeyDown;
        document.onkeyup = onKeyUp;

        showThreshold();
        document.getElementById("blurRadius").value = blurRadius;
        setInterval(function () {
          hatchTick();
        }, 300);
      };
      
      function uploadClick() {
        document.getElementById("file-upload").click();
      }
      function onRadiusChange(e) {
        blurRadius = e.target.value;
      }
      function imgChange(inp) {
        if (inp.files && inp.files[0]) {
          var reader = new FileReader();
          reader.onload = function (e) {
            var img = document.getElementById("test-picture");
            img.setAttribute("src", e.target.result);
            img.onload = function () {
              window.initCanvas(img);
            };
          };
          reader.readAsDataURL(inp.files[0]);
        }
      }
      function initCanvas() {
        // var cvs = document.querySelector(".upper-canvas");
        var cvs = document.querySelector(".upper-canvas");
        imageInfo = {
          width: cvs.width,
          height: cvs.height,
          context: cvs.getContext("2d"),
        };
        imageInfo.data = cvs.getContext("2d").getImageData(
          0,
          0,
          imageInfo.width,
          imageInfo.height
        );
        mask = null;
        
      }
      function getMousePosition(e) {
        var p = $(e.target).offset(),
          x = Math.round((e.clientX || e.pageX) - p.left),
          y = Math.round((e.clientY || e.pageY) - p.top);
        return { x: x, y: y };
      }
      function onMouseDown(e) {
        if (e.button == 0) {
          allowDraw = true;
          addMode = e.ctrlKey;
          downPoint = getMousePosition(e);
          drawMask(downPoint.x, downPoint.y);
        } else {
          allowDraw = false;
          addMode = false;
          oldMask = null;
        }
      }
      function onMouseMove(e) {
        if (allowDraw) {
          var p = getMousePosition(e);
          if (p.x != downPoint.x || p.y != downPoint.y) {
            var dx = p.x - downPoint.x,
              dy = p.y - downPoint.y,
              len = Math.sqrt(dx * dx + dy * dy),
              adx = Math.abs(dx),
              ady = Math.abs(dy),
              sign = adx > ady ? dx / adx : dy / ady;
            sign = sign < 0 ? sign / 5 : sign / 3;
            var thres = Math.min(
              Math.max(colorThreshold + Math.floor(sign * len), 1),
              255
            );
            //var thres = Math.min(colorThreshold + Math.floor(len / 3), 255);
            if (thres != currentThreshold) {
              currentThreshold = thres;
              drawMask(downPoint.x, downPoint.y);
            }
          }
        }
      }
      function onMouseUp(e) {
        allowDraw = false;
        addMode = false;
        oldMask = null;
        currentThreshold = colorThreshold;
      }
      function onKeyDown(e) {
        if (e.keyCode == 17)
          document.getElementById("upper-canvas").classList.add("add-mode");
      }
      function onKeyUp(e) {
        if (e.keyCode == 17)
          document.getElementById("upper-canvas").classList.remove("add-mode");
      }
      function showThreshold() {
        document.getElementById("threshold").innerHTML =
          "Threshold: " + currentThreshold;
      }
      function drawMask(x, y) {
        // alert(imageInfo);
        if (!imageInfo) return;

        // alert(y+'y');
        showThreshold();

        var image = {
          data: imageInfo.data.data,
          width: imageInfo.width,
          height: imageInfo.height,
          bytes: 4,
        };

        if (addMode && !oldMask) {
          oldMask = mask;
        }

        let old = oldMask ? oldMask.data : null;

        mask = MagicWand.floodFill(image, x, y, currentThreshold, old, true);
        if (mask) mask = MagicWand.gaussBlurOnlyBorder(mask, blurRadius, old);

        if (addMode && oldMask) {
          mask = mask ? concatMasks(mask, oldMask) : oldMask;
        }

        drawBorder();
      }
      function hatchTick() {
        hatchOffset = (hatchOffset + 1) % (hatchLength * 2);
        drawBorder(true);
      }
      function drawBorder(noBorder) {
        if (!mask) return;

        var x,
          y,
          i,
          j,
          k,
          w = imageInfo.width,
          h = imageInfo.height,
          ctx = imageInfo.context,
          imgData = ctx.createImageData(w, h),
          res = imgData.data;

        if (!noBorder) cacheInd = MagicWand.getBorderIndices(mask);

        ctx.clearRect(0, 0, w, h);

        var len = cacheInd.length;
        for (j = 0; j < len; j++) {
          i = cacheInd[j];
          x = i % w; // calc x by index
          y = (i - x) / w; // calc y by index
          k = (y * w + x) * 4;
          if ((x + y + hatchOffset) % (hatchLength * 2) < hatchLength) {
            // detect hatch color
            res[k + 3] = 255; // black, change only alpha
          } else {
            res[k] = 255; // white
            res[k + 1] = 255;
            res[k + 2] = 255;
            res[k + 3] = 255;
          }
        }

        ctx.putImageData(imgData, 0, 0);
      }
      function trace() {
        var cs = MagicWand.traceContours(mask);
        cs = MagicWand.simplifyContours(cs, simplifyTolerant, simplifyCount);

        mask = null;

        // draw contours
        var ctx = imageInfo.context;
        ctx.clearRect(0, 0, imageInfo.width, imageInfo.height);
        //inner
        ctx.beginPath();
        for (var i = 0; i < cs.length; i++) {
          if (!cs[i].inner) continue;
          var ps = cs[i].points;
          ctx.moveTo(ps[0].x, ps[0].y);
          for (var j = 1; j < ps.length; j++) {
            ctx.lineTo(ps[j].x, ps[j].y);
          }
        }
        ctx.strokeStyle = "red";
        ctx.stroke();
        //outer
        ctx.beginPath();
        for (var i = 0; i < cs.length; i++) {
          if (cs[i].inner) continue;
          var ps = cs[i].points;
          ctx.moveTo(ps[0].x, ps[0].y);
          for (var j = 1; j < ps.length; j++) {
            ctx.lineTo(ps[j].x, ps[j].y);
          }
        }
        ctx.strokeStyle = "blue";
        ctx.stroke();
      }
      function paint(color, alpha) {
        if (!mask) return;

        var rgba = hexToRgb(color, alpha);

        var x,
          y,
          data = mask.data,
          bounds = mask.bounds,
          maskW = mask.width,
          w = imageInfo.width,
          h = imageInfo.height,
          ctx = imageInfo.context,
          imgData = ctx.createImageData(w, h),
          res = imgData.data;

        for (y = bounds.minY; y <= bounds.maxY; y++) {
          for (x = bounds.minX; x <= bounds.maxX; x++) {
            if (data[y * maskW + x] == 0) continue;
            k = (y * w + x) * 4;
            res[k] = rgba[0];
            res[k + 1] = rgba[1];
            res[k + 2] = rgba[2];
            res[k + 3] = rgba[3];
          }
        }

        mask = null;

        ctx.putImageData(imgData, 0, 0);
      }
      function hexToRgb(hex, alpha) {
        var int = parseInt(hex, 16);
        var r = (int >> 16) & 255;
        var g = (int >> 8) & 255;
        var b = int & 255;

        return [r, g, b, Math.round(alpha * 255)];
      }
      function concatMasks(mask, old) {
        let data1 = old.data,
          data2 = mask.data,
          w1 = old.width,
          w2 = mask.width,
          b1 = old.bounds,
          b2 = mask.bounds,
          b = {
            // bounds for new mask
            minX: Math.min(b1.minX, b2.minX),
            minY: Math.min(b1.minY, b2.minY),
            maxX: Math.max(b1.maxX, b2.maxX),
            maxY: Math.max(b1.maxY, b2.maxY),
          },
          w = old.width, // size for new mask
          h = old.height,
          i,
          j,
          k,
          k1,
          k2,
          len;

        let result = new Uint8Array(w * h);

        // copy all old mask
        len = b1.maxX - b1.minX + 1;
        i = b1.minY * w + b1.minX;
        k1 = b1.minY * w1 + b1.minX;
        k2 = b1.maxY * w1 + b1.minX + 1;
        // walk through rows (Y)
        for (k = k1; k < k2; k += w1) {
          result.set(data1.subarray(k, k + len), i); // copy row
          i += w;
        }

        // copy new mask (only "black" pixels)
        len = b2.maxX - b2.minX + 1;
        i = b2.minY * w + b2.minX;
        k1 = b2.minY * w2 + b2.minX;
        k2 = b2.maxY * w2 + b2.minX + 1;
        // walk through rows (Y)
        for (k = k1; k < k2; k += w2) {
          // walk through cols (X)
          for (j = 0; j < len; j++) {
            if (data2[k + j] === 1) result[i + j] = 1;
          }
          i += w;
        }

        return {
          data: result,
          width: w,
          height: h,
          bounds: b,
        };
      }
    </script>


    <script>
      const pixie = new Pixie({
        selector: "#editor-container",
        baseUrl: "assets",
        image: "assets/images/samples/sample1.jpg",
        ui: {
          menubar: {
            items: [
              {
                type: "button",
                icon: [
                  {
                    tag: "path",
                    attr: {
                      d: "m11.99 18.54-7.37-5.73L3 14.07l9 7 9-7-1.63-1.27zM12 16l7.36-5.73L21 9l-9-7-9 7 1.63 1.27L12 16zm0-11.47L17.74 9 12 13.47 6.26 9 12 4.53z",
                    },
                  },
                ],
                align: "right",
                position: 0,
                action: (editor) => {
                  editor.togglePanel("objects");
                },
              },
              {
                type: "button",
                icon: [
                  {
                    tag: "path",
                    attr: {
                      d: "M18 20H4V6h9V4H4c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-9h-2v9zm-7.79-3.17-1.96-2.36L5.5 18h11l-3.54-4.71zM20 4V1h-2v3h-3c.01.01 0 2 0 2h3v2.99c.01.01 2 0 2 0V6h3V4h-3z",
                    },
                  },
                ],
                align: "left",
                buttonVariant: "outline",
                menuItems: [
                  {
                    action: (editor) => {
                      editor.tools.import.uploadAndReplaceMainImage();
                    },
                    label: "Background Image",
                  },
                  {
                    action: (editor) => {
                      editor.tools.import.uploadAndAddImage();
                    },
                    label: "Overlay Image",
                  },
                  {
                    action: (editor) => {
                      editor.tools.import.uploadAndOpenStateFile();
                    },
                    label: "Editor Project File",
                  },
                ],
              },
            ],
          },
        },
      });
      window.pixie = pixie;
      setTimeout(function() {
        initCanvas();
      }, 5000); // 1000 milliseconds (1 second) delay

    </script>

  </body>
</html>
